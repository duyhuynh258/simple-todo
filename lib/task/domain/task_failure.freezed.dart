// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'task_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$TaskFailureTearOff {
  const _$TaskFailureTearOff();

  Unexpected unexpected() {
    return const Unexpected();
  }

  _NoInternet noInternet() {
    return const _NoInternet();
  }

  InsufficientPermissions insufficientPermissions() {
    return const InsufficientPermissions();
  }

  UnableToUpdate unableToUpdate() {
    return const UnableToUpdate();
  }

  _LocalStorage localStorage() {
    return const _LocalStorage();
  }

  _CreatedLocalButSyncFailed createdLocalButSyncFailed(
      {required Task localTask}) {
    return _CreatedLocalButSyncFailed(
      localTask: localTask,
    );
  }
}

/// @nodoc
const $TaskFailure = _$TaskFailureTearOff();

/// @nodoc
mixin _$TaskFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() noInternet,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() localStorage,
    required TResult Function(Task localTask) createdLocalButSyncFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(_NoInternet value) noInternet,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(_LocalStorage value) localStorage,
    required TResult Function(_CreatedLocalButSyncFailed value)
        createdLocalButSyncFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TaskFailureCopyWith<$Res> {
  factory $TaskFailureCopyWith(
          TaskFailure value, $Res Function(TaskFailure) then) =
      _$TaskFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$TaskFailureCopyWithImpl<$Res> implements $TaskFailureCopyWith<$Res> {
  _$TaskFailureCopyWithImpl(this._value, this._then);

  final TaskFailure _value;
  // ignore: unused_field
  final $Res Function(TaskFailure) _then;
}

/// @nodoc
abstract class $UnexpectedCopyWith<$Res> {
  factory $UnexpectedCopyWith(
          Unexpected value, $Res Function(Unexpected) then) =
      _$UnexpectedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnexpectedCopyWithImpl<$Res> extends _$TaskFailureCopyWithImpl<$Res>
    implements $UnexpectedCopyWith<$Res> {
  _$UnexpectedCopyWithImpl(Unexpected _value, $Res Function(Unexpected) _then)
      : super(_value, (v) => _then(v as Unexpected));

  @override
  Unexpected get _value => super._value as Unexpected;
}

/// @nodoc

class _$Unexpected extends Unexpected {
  const _$Unexpected() : super._();

  @override
  String toString() {
    return 'TaskFailure.unexpected()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Unexpected);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() noInternet,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() localStorage,
    required TResult Function(Task localTask) createdLocalButSyncFailed,
  }) {
    return unexpected();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
  }) {
    return unexpected?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(_NoInternet value) noInternet,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(_LocalStorage value) localStorage,
    required TResult Function(_CreatedLocalButSyncFailed value)
        createdLocalButSyncFailed,
  }) {
    return unexpected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
  }) {
    return unexpected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (unexpected != null) {
      return unexpected(this);
    }
    return orElse();
  }
}

abstract class Unexpected extends TaskFailure {
  const factory Unexpected() = _$Unexpected;
  const Unexpected._() : super._();
}

/// @nodoc
abstract class _$NoInternetCopyWith<$Res> {
  factory _$NoInternetCopyWith(
          _NoInternet value, $Res Function(_NoInternet) then) =
      __$NoInternetCopyWithImpl<$Res>;
}

/// @nodoc
class __$NoInternetCopyWithImpl<$Res> extends _$TaskFailureCopyWithImpl<$Res>
    implements _$NoInternetCopyWith<$Res> {
  __$NoInternetCopyWithImpl(
      _NoInternet _value, $Res Function(_NoInternet) _then)
      : super(_value, (v) => _then(v as _NoInternet));

  @override
  _NoInternet get _value => super._value as _NoInternet;
}

/// @nodoc

class _$_NoInternet extends _NoInternet {
  const _$_NoInternet() : super._();

  @override
  String toString() {
    return 'TaskFailure.noInternet()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _NoInternet);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() noInternet,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() localStorage,
    required TResult Function(Task localTask) createdLocalButSyncFailed,
  }) {
    return noInternet();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
  }) {
    return noInternet?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (noInternet != null) {
      return noInternet();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(_NoInternet value) noInternet,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(_LocalStorage value) localStorage,
    required TResult Function(_CreatedLocalButSyncFailed value)
        createdLocalButSyncFailed,
  }) {
    return noInternet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
  }) {
    return noInternet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (noInternet != null) {
      return noInternet(this);
    }
    return orElse();
  }
}

abstract class _NoInternet extends TaskFailure {
  const factory _NoInternet() = _$_NoInternet;
  const _NoInternet._() : super._();
}

/// @nodoc
abstract class $InsufficientPermissionsCopyWith<$Res> {
  factory $InsufficientPermissionsCopyWith(InsufficientPermissions value,
          $Res Function(InsufficientPermissions) then) =
      _$InsufficientPermissionsCopyWithImpl<$Res>;
}

/// @nodoc
class _$InsufficientPermissionsCopyWithImpl<$Res>
    extends _$TaskFailureCopyWithImpl<$Res>
    implements $InsufficientPermissionsCopyWith<$Res> {
  _$InsufficientPermissionsCopyWithImpl(InsufficientPermissions _value,
      $Res Function(InsufficientPermissions) _then)
      : super(_value, (v) => _then(v as InsufficientPermissions));

  @override
  InsufficientPermissions get _value => super._value as InsufficientPermissions;
}

/// @nodoc

class _$InsufficientPermissions extends InsufficientPermissions {
  const _$InsufficientPermissions() : super._();

  @override
  String toString() {
    return 'TaskFailure.insufficientPermissions()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is InsufficientPermissions);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() noInternet,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() localStorage,
    required TResult Function(Task localTask) createdLocalButSyncFailed,
  }) {
    return insufficientPermissions();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
  }) {
    return insufficientPermissions?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (insufficientPermissions != null) {
      return insufficientPermissions();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(_NoInternet value) noInternet,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(_LocalStorage value) localStorage,
    required TResult Function(_CreatedLocalButSyncFailed value)
        createdLocalButSyncFailed,
  }) {
    return insufficientPermissions(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
  }) {
    return insufficientPermissions?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (insufficientPermissions != null) {
      return insufficientPermissions(this);
    }
    return orElse();
  }
}

abstract class InsufficientPermissions extends TaskFailure {
  const factory InsufficientPermissions() = _$InsufficientPermissions;
  const InsufficientPermissions._() : super._();
}

/// @nodoc
abstract class $UnableToUpdateCopyWith<$Res> {
  factory $UnableToUpdateCopyWith(
          UnableToUpdate value, $Res Function(UnableToUpdate) then) =
      _$UnableToUpdateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnableToUpdateCopyWithImpl<$Res> extends _$TaskFailureCopyWithImpl<$Res>
    implements $UnableToUpdateCopyWith<$Res> {
  _$UnableToUpdateCopyWithImpl(
      UnableToUpdate _value, $Res Function(UnableToUpdate) _then)
      : super(_value, (v) => _then(v as UnableToUpdate));

  @override
  UnableToUpdate get _value => super._value as UnableToUpdate;
}

/// @nodoc

class _$UnableToUpdate extends UnableToUpdate {
  const _$UnableToUpdate() : super._();

  @override
  String toString() {
    return 'TaskFailure.unableToUpdate()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UnableToUpdate);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() noInternet,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() localStorage,
    required TResult Function(Task localTask) createdLocalButSyncFailed,
  }) {
    return unableToUpdate();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
  }) {
    return unableToUpdate?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(_NoInternet value) noInternet,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(_LocalStorage value) localStorage,
    required TResult Function(_CreatedLocalButSyncFailed value)
        createdLocalButSyncFailed,
  }) {
    return unableToUpdate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
  }) {
    return unableToUpdate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (unableToUpdate != null) {
      return unableToUpdate(this);
    }
    return orElse();
  }
}

abstract class UnableToUpdate extends TaskFailure {
  const factory UnableToUpdate() = _$UnableToUpdate;
  const UnableToUpdate._() : super._();
}

/// @nodoc
abstract class _$LocalStorageCopyWith<$Res> {
  factory _$LocalStorageCopyWith(
          _LocalStorage value, $Res Function(_LocalStorage) then) =
      __$LocalStorageCopyWithImpl<$Res>;
}

/// @nodoc
class __$LocalStorageCopyWithImpl<$Res> extends _$TaskFailureCopyWithImpl<$Res>
    implements _$LocalStorageCopyWith<$Res> {
  __$LocalStorageCopyWithImpl(
      _LocalStorage _value, $Res Function(_LocalStorage) _then)
      : super(_value, (v) => _then(v as _LocalStorage));

  @override
  _LocalStorage get _value => super._value as _LocalStorage;
}

/// @nodoc

class _$_LocalStorage extends _LocalStorage {
  const _$_LocalStorage() : super._();

  @override
  String toString() {
    return 'TaskFailure.localStorage()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _LocalStorage);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() noInternet,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() localStorage,
    required TResult Function(Task localTask) createdLocalButSyncFailed,
  }) {
    return localStorage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
  }) {
    return localStorage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (localStorage != null) {
      return localStorage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(_NoInternet value) noInternet,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(_LocalStorage value) localStorage,
    required TResult Function(_CreatedLocalButSyncFailed value)
        createdLocalButSyncFailed,
  }) {
    return localStorage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
  }) {
    return localStorage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (localStorage != null) {
      return localStorage(this);
    }
    return orElse();
  }
}

abstract class _LocalStorage extends TaskFailure {
  const factory _LocalStorage() = _$_LocalStorage;
  const _LocalStorage._() : super._();
}

/// @nodoc
abstract class _$CreatedLocalButSyncFailedCopyWith<$Res> {
  factory _$CreatedLocalButSyncFailedCopyWith(_CreatedLocalButSyncFailed value,
          $Res Function(_CreatedLocalButSyncFailed) then) =
      __$CreatedLocalButSyncFailedCopyWithImpl<$Res>;
  $Res call({Task localTask});

  $TaskCopyWith<$Res> get localTask;
}

/// @nodoc
class __$CreatedLocalButSyncFailedCopyWithImpl<$Res>
    extends _$TaskFailureCopyWithImpl<$Res>
    implements _$CreatedLocalButSyncFailedCopyWith<$Res> {
  __$CreatedLocalButSyncFailedCopyWithImpl(_CreatedLocalButSyncFailed _value,
      $Res Function(_CreatedLocalButSyncFailed) _then)
      : super(_value, (v) => _then(v as _CreatedLocalButSyncFailed));

  @override
  _CreatedLocalButSyncFailed get _value =>
      super._value as _CreatedLocalButSyncFailed;

  @override
  $Res call({
    Object? localTask = freezed,
  }) {
    return _then(_CreatedLocalButSyncFailed(
      localTask: localTask == freezed
          ? _value.localTask
          : localTask // ignore: cast_nullable_to_non_nullable
              as Task,
    ));
  }

  @override
  $TaskCopyWith<$Res> get localTask {
    return $TaskCopyWith<$Res>(_value.localTask, (value) {
      return _then(_value.copyWith(localTask: value));
    });
  }
}

/// @nodoc

class _$_CreatedLocalButSyncFailed extends _CreatedLocalButSyncFailed {
  const _$_CreatedLocalButSyncFailed({required this.localTask}) : super._();

  @override
  final Task localTask;

  @override
  String toString() {
    return 'TaskFailure.createdLocalButSyncFailed(localTask: $localTask)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _CreatedLocalButSyncFailed &&
            (identical(other.localTask, localTask) ||
                other.localTask == localTask));
  }

  @override
  int get hashCode => Object.hash(runtimeType, localTask);

  @JsonKey(ignore: true)
  @override
  _$CreatedLocalButSyncFailedCopyWith<_CreatedLocalButSyncFailed>
      get copyWith =>
          __$CreatedLocalButSyncFailedCopyWithImpl<_CreatedLocalButSyncFailed>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unexpected,
    required TResult Function() noInternet,
    required TResult Function() insufficientPermissions,
    required TResult Function() unableToUpdate,
    required TResult Function() localStorage,
    required TResult Function(Task localTask) createdLocalButSyncFailed,
  }) {
    return createdLocalButSyncFailed(localTask);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
  }) {
    return createdLocalButSyncFailed?.call(localTask);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unexpected,
    TResult Function()? noInternet,
    TResult Function()? insufficientPermissions,
    TResult Function()? unableToUpdate,
    TResult Function()? localStorage,
    TResult Function(Task localTask)? createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (createdLocalButSyncFailed != null) {
      return createdLocalButSyncFailed(localTask);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Unexpected value) unexpected,
    required TResult Function(_NoInternet value) noInternet,
    required TResult Function(InsufficientPermissions value)
        insufficientPermissions,
    required TResult Function(UnableToUpdate value) unableToUpdate,
    required TResult Function(_LocalStorage value) localStorage,
    required TResult Function(_CreatedLocalButSyncFailed value)
        createdLocalButSyncFailed,
  }) {
    return createdLocalButSyncFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
  }) {
    return createdLocalButSyncFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Unexpected value)? unexpected,
    TResult Function(_NoInternet value)? noInternet,
    TResult Function(InsufficientPermissions value)? insufficientPermissions,
    TResult Function(UnableToUpdate value)? unableToUpdate,
    TResult Function(_LocalStorage value)? localStorage,
    TResult Function(_CreatedLocalButSyncFailed value)?
        createdLocalButSyncFailed,
    required TResult orElse(),
  }) {
    if (createdLocalButSyncFailed != null) {
      return createdLocalButSyncFailed(this);
    }
    return orElse();
  }
}

abstract class _CreatedLocalButSyncFailed extends TaskFailure {
  const factory _CreatedLocalButSyncFailed({required Task localTask}) =
      _$_CreatedLocalButSyncFailed;
  const _CreatedLocalButSyncFailed._() : super._();

  Task get localTask;
  @JsonKey(ignore: true)
  _$CreatedLocalButSyncFailedCopyWith<_CreatedLocalButSyncFailed>
      get copyWith => throw _privateConstructorUsedError;
}
